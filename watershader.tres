[gd_resource type="Shader" format=2]

[resource]
code = "shader_type spatial;

uniform vec4 WaveA;
uniform vec4 WaveB;
uniform vec4 WaveC;

vec3 GersterFunction(vec4 wave, vec3 point, inout vec3 tangent, inout vec3 binormal)
{
	float steepness = wave.z;
	float wavelength = wave.w;
	float k = 2.0*3.14159265358/wavelength;
	float c = sqrt(9.8/k);
	vec2 d = normalize(wave.xy);
	float f = k * (dot(d,point.xz)-c*TIME);
	float a = steepness/k;
	
	tangent += vec3(
		-d.x * d.x * (steepness * sin(f)),
		d.x * (steepness * cos(f)),
		-d.x * d.y * (steepness * sin(f))
		);
	binormal += vec3(
		-d.x * d.y * (steepness * sin(f)),
		d.y * (steepness * cos(f)),
		-d.y * d.y * (steepness * sin(f))
		);
	return vec3(
		d.x * (a * cos(f)),
		a * sin(f),
		d.y * (a * cos(f)));
}


void vertex()
{
	
	vec3 gridpoint = VERTEX.xyz;
	vec3 tangent = vec3(1,0,0);
	vec3 binormal = vec3(0,0,1);
	vec3 p = gridpoint;
	p+= GersterFunction(WaveA, gridpoint, tangent, binormal);
	p+= GersterFunction(WaveB, gridpoint, tangent, binormal);
	p+= GersterFunction(WaveC, gridpoint, tangent, binormal);
	vec3 normal = normalize(cross(binormal, tangent));
	VERTEX = p.xyz;
	NORMAL = normal;

	
}




uniform sampler2D diffusetex;
uniform sampler2D flowmap;
uniform sampler2D heightmap;

uniform float flow_strength;
uniform float flow_speed;
uniform float height_scale;
uniform float height_scale_modulated;
uniform float jump_a;
uniform float jump_b;
uniform vec4 color;


vec3 flowUVW(vec2 uv, vec2 flow_vector, vec2 jump, float flow_offset, float tiling, float time, bool flow_b)
{
	float phaseOffset = flow_b ? 0.5: 0.0;
	float progress = fract(time + phaseOffset);
	vec3 uvw;
	uvw.xy = uv - flow_vector * (progress * flow_offset);
	uvw.xy *= tiling;
	uvw.xy += phaseOffset;
	uvw.xy += (time - progress) * jump;
	uvw.z = 1.0 - abs(1.0-2.0*progress);
	return uvw;
}

vec3 unpackHeight(vec4 heightdata)
{
	vec3 dh = heightdata.rgb;
	dh.xy = dh.xy * 2.0 - 1.0;
	return dh;
}

void fragment()
{
	vec3 flow = texture(flowmap, UV).rgb;
	flow.xy = flow.xy * 2.0 - 1.0;
	flow *= flow_strength;
	float noise = texture(flowmap, UV).a;
	float time = TIME * flow_speed + noise;
	vec2 uvT = UV + time;
	float tiling = 10.0;
	vec2 jump;
	jump.x = jump_a;
	jump.y = jump_b;
	float offset = 0.5;
	
	vec3 uvwA = flowUVW(UV, flow.xy, jump, offset,tiling, time, false);
	vec3 uvwB = flowUVW(UV, flow.xy, jump, offset, tiling, time, true);
	
	float f_height_scale = length(flow)  * height_scale_modulated + height_scale;
	
	vec3 dhA = unpackHeight(texture(heightmap, uvwA.xy)) * (uvwA.z * f_height_scale);
	vec3 dhB = unpackHeight(texture(heightmap,uvwB.xy)) * (uvwB.z * f_height_scale);
		
	vec4 texcol1 = texture(diffusetex, uvwA.xy)*uvwA.z;
	vec4 texcol2 = texture(diffusetex, uvwB.xy)* uvwB.z;
	
	vec4 fin_col = (texcol1 + texcol2) * color;
	ALBEDO = fin_col.rgb;
	NORMALMAP.xy = normalize(-(dhA.xy + dhB.xy));
	NORMALMAP.z = 1.0;

	
	
	}"
